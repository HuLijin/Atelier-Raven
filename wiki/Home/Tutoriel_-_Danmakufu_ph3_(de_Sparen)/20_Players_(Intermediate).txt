Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2015-09-01T17:32:04+02:00

====== 20 Players (Intermediate) ======

Unfortunately, this will require a separate tutorial, as creating a player from scratch is not easy. My [Artifact 2 Marisa Player on Bulletforge] is free to download, and feel free to browse the code and try to understand how it works. Note that it is based off of GTbot's players. I highly suggest looking at the [Random Player Generator], which has what is probably the most simple yet versatile code available for study next to the default player.

//(Added)// Below is the Marisa of Sparen :

'''
#TouhouDanmakufu[Player]
#ScriptVersion[3]
#ID["A2_Marisa Sparen"]
#Title["A2 Marisa by Sparen"]
#Text["Marisa Player Script.[r]For use in the Artifact Contest 2[r]By Sparen"]
#Image["./img_Cutin.png"]
#ReplayName["A2_MariS"]

/* 
Marisa (Artifact 2)
By: Sparen
Original code taken from GTbot's Medicine A player

This player is redistributable and may be remade and redistributed as long as these conditions are followed.

'''
		'''
		Read Me!
		
		Player: A2 Marisa (by Sparen)
		
		All damage values for attacks are at maximum damage, all for spell cards are point blank range.
		
		FOR THE LOVE OF KANAKO, IF YOU DECIDE THAT YOU WANT TO RIP THIS PLAYER FOR THE ARTIFACT CONTEST #2, 
		GIVE CREDIT, CHANGE THE REPLAY NAME, AND MOST IMPORTANTLY, MAKE SOME DISTINCTION 
		IN THE PLAYER'S #TITLE or #TEXT THAT MAKES IT OBVIOUS WHICH PLAYER THIS IS.
		
		If you reuse this player, you are REQUIRED to change the spellcard completely and remember: 
		for the Artifact Contest #2, this Marisa player is NOT ALLOWED to use Master Spark. 
		(the point of the contest being)
		
		A2Marisa: Multipurpose Type
		-Speed: 4/1.5
		Unfocused Shot: 
		-Damage: ~300 DPS
		Focused Shot: 
		-Damage: ~282 DPS
		Spell Card: 
		Damage (C): 1800
		
		Please submit all bugs and suggestions to either BulletForge 
		or http://www.shrinemaiden.org/forum/index.php/topic,13738.0.html
		
		Thank you.
		
		Credits:
		-Sparen (me)
		-GTBot: For making the base code
		'''

'''

*/


let MaximumParticles = 32; // Maximum number of particles allowed
let AllowShotDecay = true; // Renders the shot degeneration effect when true
let AllowGrazePart = true; // Renders a particle when you graze when true
let GrazePartNum = 2; // Number of particles created when you graze a single bullet




/*
The following are common datas that this player uses. You may use
this data to further manipulate your scripts (or player) to your needs.					
	
 --- Common Area Data --- 
	+ Area Common Data that use the area "c_Player_v1"
	GetRenderObject 	- Gets the object that renders the player's
							image + animation
	GetPlayerSpeed		- Returns the player's normal speed in an array
							[Unshift Speed, Shift Speed]
	ForceOptionsOff		- Set to true to hide options and other objects
							that may use this value
							
*/

let TotalParticleCount = 0; //Graze particles
let GlobalSounds = [];
let GlobalSndStr = [];
let ReallyPlaying = []; //Sounds playing when game is paused
let IsGamePaused = false;

let unshiftspd = 4; //Self-explanatory.
let shiftspd = 1.5; //Self-explanatory
let playertype = 1;
let playerdead = false;
let LastDeathTimer = 0;
let TimeSpeed = 1;

let shotCount = 1;
let ShotDamage = 0;

let ActivateHitbox = false;
let RefreshOptions = false;
let ForceOptionsOff = false;
let CanShoot = true;
let CanShift = true;
let OptionShift = GetVirtualKeyState(VK_SLOWMOVE)!=KEY_FREE;
let IsTimeStopped = false;
let IsPlayerSpawning = false;


let BasePlayerObj = GetPlayerObjectID;
let objPlayer = ObjPrim_Create(OBJ_SPRITE_2D);
let current = GetCurrentScriptDirectory;

let imgPlayer = current ~ "img_Player.png"; //Contains player graphics
let imgBomb = current ~ "img_Bomb.png"; //Contains spell graphics
let imgEffect = current ~ "img_Effect.png"; //Contains hitbox & shots
let imgCutin = current ~ "img_Cutin.png"; 

@Initialize{
	LoadPlayerShotData(current ~ "a_shotdata.txt"); 
	CreateCommonDataArea("c_Player_v1");
	SetAreaCommonData("c_Player_v1", "GetRenderObject", objPlayer);
	SetAreaCommonData("c_Player_v1", "GetPlayerSpeed", [unshiftspd, shiftspd]);
	
	ObjPlayer_AddIntersectionCircleA1(BasePlayerObj, 0, 0, 2, 20); 
	
	SetPlayerRebirthFrame(16);
	SetPlayerRebirthLossFrame(0);
	SetPlayerDownStateFrame(45);
	SetPlayerSpeed(unshiftspd,shiftspd);
	SetPlayerAutoItemCollectLine(196);
	
	ShotType;
	
	CreateObjectSound("se_charge");
	CreateObjectSound("se_graze");
	CreateObjectSound("se_item");
	CreateObjectSound("se_life");
	CreateObjectSound("se_pldead");
	CreateObjectSound("se_pldead1");
	CreateObjectSound("se_pldead2");
	CreateObjectSound("se_shot");
	CreateObjectSound("se_shot2");
	CreateObjectSound("se_spark");
	CreateObjectSound("se_alarm");
	
	CreateObjectSound("se_spell1");
	CreateObjectSound("se_spell2");
	
	LoadTexture(imgPlayer);
	LoadTexture(imgEffect);
	LoadTexture(imgBomb);
	
	Obj_SetValue(objPlayer, "dinv", -1);
	RenderPlayerImage(objPlayer, 144);
	SetPlayerSpell(2);
	Spawn; //Options
	TMagicCircle; //Invincibility circle
	
	ascent(i in 0..2){
	    CreateOptionS1(BasePlayerObj, i, 1, 1);
	    CreateOptionS1(BasePlayerObj, i, 0.5, -1);
	}
}


@MainLoop{
	OptionShift = GetVirtualKeyState(VK_SLOWMOVE)!=KEY_FREE; //is the player focusing
	if(GetPlayerState==STATE_DOWN){CanShoot = false;} //Basically, is the player shooting while dead?
	if(GetPlayerState==STATE_NORMAL){CanShoot = true;}
	if(IsPermitPlayerShot==false && GetPlayerState==STATE_NORMAL){CanShoot = false;}
	if(IsPermitPlayerShot==true && GetPlayerState==STATE_NORMAL){CanShoot = true;}
	if(!IsPlayerSpawning){SetPlayerClip(11,11,GetStgFrameWidth-11,GetStgFrameHeight-18);}
	if(GetVirtualKeyState(VK_SLOWMOVE)==KEY_PUSH){RenderHitboxImage(objPlayer, 0, 1);}
	ForceOptionsOff = GetAreaCommonData("ForceOptionsOff", "c_Player_v1", false);
	Obj_SetValue(objPlayer, "dinv", Obj_GetValue(objPlayer, "dinv")-1);
	if(GetPlayerInvincibilityFrame<=0){LastDeathTimer = max(LastDeathTimer-1, 0);}
	yield;
}

@Finalize{	
	RemoveTexture(imgPlayer);
	RemoveTexture(imgEffect);
	RemoveTexture(imgBomb);
	
	RemoveSound("se_charge");
	RemoveSound("se_graze");
	RemoveSound("se_item");
	RemoveSound("se_life");
	RemoveSound("se_pldead");
	RemoveSound("se_pldead1");
	RemoveSound("se_pldead2");
	RemoveSound("se_shot");
	RemoveSound("se_shot2");
	RemoveSound("se_spark");
	RemoveSound("se_alarm");
	
	RemoveSound("se_spell1");
	RemoveSound("se_spell2");
}


@Event{
	alternative(GetEventType)
	case(EV_PAUSE_ENTER){StopAllSounds;IsGamePaused = true;} //pause menu functions
	case(EV_PAUSE_LEAVE){ResumeSounds;IsGamePaused = false;}
	case(EV_END_BOSS_STEP){
	}
	case(EV_GAIN_SPELL){
	}
	case(EV_REQUEST_SPELL){ //Bombing
		if(GetPlayerSpell>0){
			SetScriptResult(true);
			SetPlayerSpell(GetPlayerSpell-1);
			SetPlayerInvincibilityFrame(5); //Temporary?
			Spellcard; //Call the spell
		}else{SetScriptResult(false);}
	}
	case(EV_PLAYER_SHOOTDOWN){
		CanShoot = false;
		playerdead = true;
	}
	case(EV_HIT){ //Death
		loop(32){MapleLeaf(GetPlayerX, GetPlayerY, rand(0,360), rand(85, 185), 2.8);}
		DeathExplosion(0);
		ClearEnemyBullets(GetPlayerX, GetPlayerY, 0, 2, 10, 0);
		PlaySound("se_pldead1");
	}
	case(EV_PLAYER_REBIRTH){
		LastDeathTimer = 0;
		SetPlayerRebirthFrame(16); //Deathbomb window
		SetPlayerRebirthLossFrame(0); //SetRebirthFrameReduction
		SetPlayerSpell(max(2, GetPlayerSpell)); //Restock bombs
		ClearEnemyBullets(GetPlayerX, GetPlayerY, 30, 50, 900, 0);
		SetPlayerInvincibilityFrame(240);
		playerdead = false;
		Spawn;
	}
	case(EV_GET_ITEM){
		alternative(GetEventArgument(0))
		case(ITEM_1UP){
			PlaySound("se_life");
		}
		case(ITEM_1UP_S){
			PlaySound("se_life");
		}
		case(ITEM_SPELL){
			PlaySound("se_life");
		}
		case(ITEM_SPELL_S){
			PlaySound("se_life");
		}
		others{
			PlaySound("se_item");
		}
	}
	case(EV_GRAZE){
		PlaySound("se_graze");
		loop(GrazePartNum){Particle(GetPlayerX, GetPlayerY, rand(0,360), rand(15, 85), 0.8);}
		AddScore(2000);
	}
}

task Spawn{
	let obj = GetPlayerObjectID;
	let y = 0;
	ObjRender_SetX(obj, GetStgFrameWidth/2); //Spawn in middle of screen
	ObjRender_SetY(obj, GetStgFrameHeight-32); //Spawn at bottom
	SetPlayerSpeed(0,0); //Can't move upon startup
	IsPlayerSpawning = true;
	while(y<82){ //82 frames to move to position
		if(IsTimeStopped==false){
			SetPlayerClip(11,11,GetStgFrameWidth-11,GetStgFrameHeight+64);	
			SetPlayerSpeed(0,0);
			ObjRender_SetY(obj, GetStgFrameHeight+32-y);
			y+=2/TimeSpeed;
		}
		yield;
	}
	IsPlayerSpawning = false;
	SetPlayerSpeed(unshiftspd,shiftspd);
}


task RenderPlayerImage(ObjectRender, offset){
	let anim_count = 0; //animframe for player sprite
	let anim_type = 0; //0 still, 1 left, 2 right
	let Uber = 0; //Makes player blink
	let Uberblink = 0;
	
	let x = 32;
	let y = 48;
	let ri = 10; //Idle sprite delay
	let rm = 4; //Idle sprite movement
	let bn = 0; //Make first four frames faster
	
	ObjPrim_SetTexture(ObjectRender, imgPlayer);
	Obj_SetRenderPriority(ObjectRender, 0.45);
	
	while(!Obj_IsDeleted(ObjectRender)){
	    if(GetPlayerState!=STATE_DOWN){ //When dead
		ObjRender_SetAlpha(ObjectRender, 255);
	    }
	
	    if(GetPlayerState!=STATE_NORMAL || playerdead == true){ObjRender_SetAlpha(ObjectRender, 0);}
	    ObjRender_SetPosition(ObjectRender, GetPlayerX, GetPlayerY, 0);
		
	    if(IsPlayerSpawning==false){
    	        if(IsTimeStopped == false){
		    Blink;
		    if(GetVirtualKeyState(VK_RIGHT) == KEY_FREE && GetVirtualKeyState(VK_LEFT) == KEY_FREE){
		        if(anim_type != 0){
		    	    bn = 0;
			    //anim_count = 0; //resets animation, but I only have 2 frames. So who cares.
			    anim_type = 0; //Still
			}
		    }
		    if(GetVirtualKeyState(VK_LEFT) == KEY_PUSH || GetVirtualKeyState(VK_LEFT) == KEY_HOLD){
		        if(GetVirtualKeyState(VK_RIGHT) != KEY_HOLD && anim_type != 1){
			    bn = 0.85;
			    //anim_count = 0;
			    anim_type = 1; //Left
			}
	            }
		    if(GetVirtualKeyState(VK_RIGHT) == KEY_PUSH || GetVirtualKeyState(VK_RIGHT) == KEY_HOLD){
		        if(anim_type != 2){
			    bn = 0.85;
			    //anim_count = 0;
			    anim_type = 2; //Right
			}
	            }
		    anim_count+=(1+bn)/TimeSpeed;
		    if(floor(anim_count) != anim_count && TimeSpeed == 1 && bn == 0){
	                anim_count = floor(anim_count);
		    }
		}
	    }else{
		if(IsTimeStopped==false){
		    Blink;
		    anim_count+=1/TimeSpeed;
		    if(anim_type != 0){
		        anim_count = 0;
			anim_type = 0;
		    }
		}
	    }
	    //0 - Idle; 1 - Left; 2 - Right;
	    if(!IsTimeStopped){ //Done
              if(anim_type == 0){
		  ObjSprite2D_SetSourceRect(ObjectRender, 0+floor(anim_count/8)*32, 0, 32+floor(anim_count/8)*32, 48);
	      }
              if(anim_type == 1){
		  ObjSprite2D_SetSourceRect(ObjectRender, 0+floor(anim_count/8)*32, 48, 32+floor(anim_count/8)*32, 96);
	      }
              if(anim_type == 2){
		  ObjSprite2D_SetSourceRect(ObjectRender, 0+floor(anim_count/8)*32, 96, 32+floor(anim_count/8)*32, 144);
	      }

	      if(anim_count>=95){anim_count = 0;}

	      ObjRender_SetScaleXYZ(ObjectRender, 1, 1, 1); 
            }
            anim_count++;
	    ObjSprite2D_SetDestCenter(ObjectRender); //Automatically centers object for drawing
	    yield;
	}
	task Blink{
		if(GetPlayerInvincibilityFrame>0){
			if(Uber==0){ObjRender_SetColor(ObjectRender, 255, 255, 255);}
			if(Uber!=0){ObjRender_SetColor(ObjectRender, 32, 32, 255);}
			Uberblink+=1;
			if(Uberblink>1){Uberblink=0;Uber++;if(Uber>1){Uber=0}}
		}else{
			ObjRender_SetColor(ObjectRender, 255, 255, 255);
		}
	}
}

task RenderHitboxImage(plobj, offx, hitboxnum){ //GTBOT
	yield;yield;yield;
	while(IsPlayerSpawning||playerdead){
		if(GetVirtualKeyState(VK_SLOWMOVE)!=KEY_HOLD){return;}
		yield;
	}
	let obj = ObjPrim_Create(OBJ_SPRITE_2D);
	ObjRender_SetBlendType(obj, BLEND_ALPHA);
	Obj_SetRenderPriority(obj, 0.39);
	ObjRender_SetAlpha(obj, 235);
	ObjPrim_SetTexture(obj, imgEffect);
	ObjSprite2D_SetSourceRect(obj, 64, 224, 127, 287);
	ObjSprite2D_SetDestCenter(obj);
	
	let obj2 = ObjPrim_Create(OBJ_SPRITE_2D);
	ObjRender_SetBlendType(obj2, BLEND_ALPHA);
	Obj_SetRenderPriority(obj2, 0.69);
	ObjRender_SetAlpha(obj2, 235);
	ObjPrim_SetTexture(obj2, imgEffect);
	ObjSprite2D_SetSourceRect(obj2, 64, 224, 127, 287);
	ObjSprite2D_SetDestCenter(obj2);
	
	let ObjTime = 0;
	
	let AlphaSet = 0;
	let ObjAlpha = 0;
	let ObjScale = 1;
	PositionSet;
	
	while(GetVirtualKeyState(VK_SLOWMOVE)==KEY_HOLD&&ObjScale<1.4&&!playerdead){
		if(!IsTimeStopped){
			ObjTime+=8;
			ObjScale += 0.125;
			PositionSet;
		}
		yield;
	}
	while(GetVirtualKeyState(VK_SLOWMOVE)==KEY_HOLD&&ObjScale>1&&!playerdead){
		if(!IsTimeStopped){
			ObjTime+=8;
			ObjScale -= 0.1;
			PositionSet;
		}
		yield;
	}
	ObjScale = 1;
	yield;
	while(GetVirtualKeyState(VK_SLOWMOVE)==KEY_HOLD&&!playerdead){
		if(!IsTimeStopped){
			ObjTime+=3;
			PositionSet;
		}
		yield;
	}
	
	while(ObjScale>0){
		if(!IsTimeStopped){
			ObjTime+=3;
			ObjScale -= 0.1;
			PositionSet;
		}
		yield;
	}

	Obj_Delete(obj);
	Obj_Delete(obj2);
	
	task PositionSet{
		if(GetVirtualKeyState(VK_SLOWMOVE)==KEY_PUSH){ObjScale = 0;}
		ObjRender_SetPosition(obj, GetPlayerX, GetPlayerY, 0);
		ObjRender_SetAngleZ(obj, ObjTime);
		ObjRender_SetPosition(obj2, GetPlayerX, GetPlayerY, 0);
		ObjRender_SetScaleXYZ(obj, ObjScale, ObjScale, ObjScale);
		ObjRender_SetScaleXYZ(obj2, ObjScale, ObjScale, ObjScale);
	}
	
}


task DeathExplosion(offx){ //GTBOT
	let obj = ObjPrim_Create(OBJ_SPRITE_2D);
	ObjRender_SetBlendType(obj, BLEND_ALPHA);
	Obj_SetRenderPriority(obj, 0.60);
	ObjPrim_SetTexture(obj, imgEffect);
	ObjSprite2D_SetSourceRect(obj, 198, 232, 262, 296);
	ObjSprite2D_SetDestRect(obj, -32, -32, 32, 32);
	let alpha = 175;
	let scale = 0.8;
	let expo = 0.7;
	ObjRender_SetPosition(obj, GetPlayerX+offx, GetPlayerY, 0);
	while(alpha>0){
		scale += expo/TimeSpeed;
		alpha -= 7/TimeSpeed;
		if(expo>0){expo -=0.0085/TimeSpeed;}
		ObjRender_SetAlpha(obj, alpha);
		ObjRender_SetScaleXYZ(obj, scale/3, scale/3, 1);
		yield;
	}
	yield;Obj_Delete(obj);
}

task ClearEnemyBullets(x, y, Tsize, Tspd, Tmaxrad, delay){ //GTBOT. Used when dying and rebirthing
	let barray = GetShotIdInCircleA2(x, y, Tsize, TARGET_ENEMY);
	let stopclear = true;
	loop(delay){yield;}
	while(Tsize<Tmaxrad){
		barray = GetShotIdInCircleA2(x, y, Tsize, TARGET_ENEMY);
		ascent(i in 0..length(barray)){
			let o = barray[i];
			if(!ObjShot_IsSpellResist(o)){ObjShot_SetDeleteFrame(o, 0);}
		}
		Tsize += Tspd;
		yield;
	}
}

task ShadowA1(dumobj, incremental, alpha, colorR, colorG, colorB){ //Used in the spell
	SubtractBG(dumobj);
	let obj = ObjPrim_Create(OBJ_SPRITE_2D);
	let xBend = 1;
	let BendInc = 0.22;
	ObjRender_SetBlendType(obj, BLEND_ALPHA);
	Obj_SetRenderPriority(obj, 0.30);
	ObjRender_SetAlpha(obj, alpha);
	ObjPrim_SetTexture(obj, imgEffect);
	ObjSprite2D_SetSourceRect(obj, 0, 234, 62, 296);
	ObjSprite2D_SetDestRect(obj, -xBend, -xBend, xBend, xBend);
	ObjRender_SetPosition(obj, GetPlayerX, GetPlayerY, 0);
	ObjRender_SetColor(obj, colorR, colorG, colorB);
	while(!Obj_IsDeleted(dumobj)){
		ObjSprite2D_SetDestRect(obj, -xBend, -xBend, xBend, xBend);
		if(xBend<1500){
			xBend+=BendInc;
			BendInc+=incremental/TimeSpeed;
		}
		yield;
	}
	while(alpha>0){
		alpha -= 3/TimeSpeed;
		ObjRender_SetAlpha(obj, alpha);
		yield;
	}
	Obj_Delete(obj);
}

task SubtractBG(dumobj){ //GTBOT. Red and blue shadow effect
	loop(32){yield}
	let bg = ObjPrim_Create(OBJ_SPRITE_2D);
	let fade = 0;
	ObjRender_SetBlendType(bg, BLEND_SUBTRACT);
	Obj_SetRenderPriority(bg, 0.28);
	ObjPrim_SetTexture(bg, NULL);
	ObjSprite2D_SetSourceRect(bg, 0, 0, 1, 1);
	ObjSprite2D_SetDestRect(bg, -48, -48, GetStgFrameWidth+48, GetStgFrameHeight+48);
	ObjRender_SetColor(bg, fade, fade, fade);
	
	let incv = 0;
	let shift = 0;
	
	while(!Obj_IsDeleted(dumobj)){
		fade = min(1, fade+0.03);
		UpCol;
		yield;
	}
	while(fade>0){
		fade-=0.05;
		UpCol;
		yield;
	}
	Obj_Delete(bg);
	function UpCol{
		incv++;
		shift = 16*cos(incv);
		ObjRender_SetColor(bg, (48+shift)*fade, (64*fade), (48-shift)*fade);
	}
}

task ShadowA2(x, y, alpha, alphinc, colorR, colorG, colorB){ //Idk
	let obj = ObjPrim_Create(OBJ_SPRITE_2D);
	let ShadowTime = 0;
	let xBend = 1250;
	let BendInc = 0.22;
	let ShadSet = 0;
	ObjRender_SetBlendType(obj, BLEND_ALPHA);
	Obj_SetRenderPriority(obj, 0.69);
	ObjRender_SetAlpha(obj, alpha);
	ObjPrim_SetTexture(obj, imgEffect);
	ObjSprite2D_SetSourceRect(obj, 0, 234, 62, 296);
	ObjSprite2D_SetDestRect(obj, -xBend, -xBend, xBend, xBend);
	ObjRender_SetPosition(obj, x, y, 0);
	ObjRender_SetColor(obj, colorR, colorG, colorB);
	while(alpha>0){
		alpha += alphinc;
		ObjRender_SetAlpha(obj, alpha);
		yield;
	}
	Obj_Delete(obj);
}

task ShotType{ //Player shooting
	let loopCount = 0;
	loop{
	    FireShotData;
	    PlayerShoot;
	    yield;
	}
	
	task FireShotData{
	    if(GetVirtualKeyState(VK_SHOT)!=KEY_FREE&&GetPlayerState==STATE_NORMAL){ //Not shooting
		loopCount = 1;
	    }
	    if(loopCount>0){
		if(!IsTimeStopped){
		    loopCount++;
		    shotCount-=1/TimeSpeed;
		}
		if(loopCount>28||IsPlayerSpawning){ //How long to shoot for after letting go of key
		    loopCount = 0;
		    shotCount = 1;
		}
	    }
	}
	task PlayerShoot{
	    if(shotCount <= 0 && CanShoot){
	        PlaySound("se_shot");
		if(GetVirtualKeyState(VK_SLOWMOVE)!=KEY_HOLD&&GetVirtualKeyState(VK_SLOWMOVE)!=KEY_PUSH){//Unfoc
		    CreatePlayerObjShotA1(GetPlayerX-8, GetPlayerY-16, 24, 270, 3, 1, 1, false); 
		    CreatePlayerObjShotA1(GetPlayerX+8, GetPlayerY-16, 24, 270, 3, 1, 1, false);
		    CreatePlayerObjShotA1(GetPlayerX-8, GetPlayerY-16, 24, 285, 2, 2, 2, false); 
		    CreatePlayerObjShotA1(GetPlayerX+8, GetPlayerY-16, 24, 255, 2, 2, 2, false);
		}else{ //foc
		    CreatePlayerObjShotA1(GetPlayerX-8, GetPlayerY-16, 24, 270, 3, 1, 1, false); 
		    CreatePlayerObjShotA1(GetPlayerX+8, GetPlayerY-16, 24, 270, 3, 1, 1, false);
		    CreatePlayerObjShotA1(GetPlayerX-8, GetPlayerY-16, 24, 275, 1, 2, 2, false); 
		    CreatePlayerObjShotA1(GetPlayerX+8, GetPlayerY-16, 24, 265, 1, 2, 2, false);		
		}
		yield;
		shotCount = 4;
	    }
	}
}

task CreatePlayerObjShotA1(ShotX, ShotY, Shotspd, Shotangle, Shotdmg, Shotpenetration, Shotgraphic, sdamage){
	let ShotObj = CreatePlayerShotA1(ShotX, ShotY, Shotspd, Shotangle, Shotdmg, Shotpenetration, Shotgraphic);
	let ShotSpell = ID_INVALID;
	if(sdamage){ //I don't get this
		ShotSpell = CreatePlayerShotA1(ShotX, ShotY, Shotspd, Shotangle, Shotdmg, Shotpenetration, Shotgraphic);
		ObjShot_SetDamage(ShotSpell, sdamage);
	}
	let X = 0;//X
	let Y = 0;//Y
	let A = 0;//Angle
	while(Obj_IsDeleted(ShotObj)==false){
		X = ObjRender_GetX(ShotObj);
		Y = ObjRender_GetY(ShotObj);
		A = ObjMove_GetAngle(ShotObj);
		ObjShot_SetDamage(ShotObj, Shotdmg);
		yield;
	}
	if(X>1 && Y >1){ShotHit(X, Y-8, A, Shotgraphic);loop(2){Particle(X, Y, A+rand(-70,70), 105, rand(0.25, 0.55))}}
}

task CreateOptionS1(robj, ID, mult, dir){ //Options!
	let objcount = 0;
	if(dir == -1){objcount = 90;}//Offset the second set of options
	let lenx = 90*mult; let leny = 30*mult; //Unfocused default
	let obj = ObjPrim_Create(OBJ_SPRITE_LIST_2D); 
	ObjPrim_SetTexture(obj, imgEffect);
	ObjRender_SetBlendType(obj, BLEND_ALPHA);
	Obj_SetRenderPriority(obj, 0.5);
	ObjSpriteList2D_SetSourceRect(obj, 205, 217, 221, 500);
	ObjSpriteList2D_SetDestCenter(obj);
	let rx = GetPlayerX; //Location
	let ry = GetPlayerY; //Location
	let alp = 0; //Alpha of option
	while(!Obj_IsDeleted(robj) && !RefreshOptions){
	    if(IsTimeStopped == false){
		if(IsPlayerSpawning || ForceOptionsOff){
		    rx = GetPlayerX;
		    ry = GetPlayerY;
		    alp = max(alp-20, 0);
		}else{
		    if(playerdead){
			alp = max(alp-20, 0);
		    }else{
		        alp = min(alp+20, 255);
		    }
		}
		posit; //Position
		rend;  //Render
		if(shotCount <= 0 && CanShoot){
		    if(GetVirtualKeyState(VK_SLOWMOVE)!=KEY_HOLD&&GetVirtualKeyState(VK_SLOWMOVE)!=KEY_PUSH){//Unf
		        CreatePlayerObjShotA1(ObjRender_GetX(obj), ObjRender_GetY(obj), 18, 270, 3, 1, 4, false);
		    }else{//Foc
			CreatePlayerObjShotA1(ObjRender_GetX(obj), ObjRender_GetY(obj), 18, 270, 3, 1, 4, false);
		    }
		}
	    }
	    objcount++;
	    yield;
	}
	Obj_Delete(obj);
	
	sub rend{
		ObjSpriteList2D_ClearVertexCount(obj);
		ObjSpriteList2D_SetSourceRect(obj, 68, 309, 84, 325);
		if(dir==-1){ObjSpriteList2D_SetSourceRect(obj, 84, 309, 100, 325);}
		ObjSpriteList2D_SetDestCenter(obj);
		ObjRender_SetAlpha(obj, 150); //Lower the alpha
		ObjRender_SetScaleXYZ(obj, 1, 1, 1);
		ObjSpriteList2D_AddVertex(obj);
	}

	sub posit{
		if(GetVirtualKeyState(VK_SLOWMOVE)!=KEY_HOLD&&GetVirtualKeyState(VK_SLOWMOVE)!=KEY_PUSH){//Unfocus
		    if(lenx<90*mult){lenx+=1*mult;}//30 frames total recovery
		    if(leny<30*mult){leny+=0.5*mult;}
		}else{//Focused option movement
		    if(lenx>60*mult){lenx-=1*mult;}
		    if(leny>15*mult){leny-=0.5*mult;}
		}
		rx=GetPlayerX+lenx*cos(objcount*dir+360/2*ID);
		ry=GetPlayerY+leny*sin(objcount*dir+360/2*ID);
		ObjRender_SetPosition(obj, rx, ry, 0);
	}
}

task Spellcard{ //Spellcard
    yield;
    SetForbidPlayerShot(true);
    let objManage = GetSpellManageObject;
    let spellcount=0;
    let countingID = 0;
    SetPlayerInvincibilityFrame(330);
    ShadowA1(objManage, 0.75, 60, 0, 0, 0);
    CutInSparen("Love Sign: Localized Starstorm");
    //loop(30){yield;}
    ScreenShakeA1(240, 2);
    PlaySound("se_spark");
    ascent(i in 0..5){spell_star(i);}
    loop(270){yield;}
    Obj_Delete(objManage); //End of spell
    SetForbidPlayerShot(false);
}

task spell_star(ID){
    let objcount = 0;
    let objspell = ObjSpell_Create;
    ObjSpell_Regist(objspell);

    ObjPrim_SetPrimitiveType(objspell, PRIMITIVE_TRIANGLEFAN);
    ObjPrim_SetVertexCount(objspell, 4);
    ObjPrim_SetTexture(objspell, imgBomb);
    Obj_SetRenderPriority(objspell, 0.59); //I'm putting it here. Hopefully that works
    ObjRender_SetBlendType(objspell, BLEND_ADD_ARGB);
    ObjPrim_SetVertexUVT(objspell, 0, 0, 224);
    ObjPrim_SetVertexUVT(objspell, 1, 256, 224);
    ObjPrim_SetVertexUVT(objspell, 2, 256, 256);
    ObjPrim_SetVertexUVT(objspell, 3, 0, 256);
    ObjPrim_SetVertexPosition(objspell, 0, -160, -6, 0);//-160 for perfection~
    ObjPrim_SetVertexPosition(objspell, 1, 64, -6, 0);
    ObjPrim_SetVertexPosition(objspell, 2, 64, 6, 0);
    ObjPrim_SetVertexPosition(objspell, 3, -160, 6, 0);
    ascent(i in 0..4){ObjPrim_SetVertexColor(objspell, i, 255, 255, 255); ObjPrim_SetVertexAlpha(objspell, i, 255);}
    while(!Obj_IsDeleted(objspell)){
        ObjRender_SetPosition(objspell, GetPlayerX+60*cos(ID*72+objcount), GetPlayerY+60*sin(ID*72+objcount), 0);
	ObjRender_SetAngleXYZ(objspell, 0, 0, ID*72+objcount+35);//Lol such perfect
	ObjSpell_SetIntersectionCircle(objspell, GetPlayerX, GetPlayerY, 120);
	ObjSpell_SetDamage(objspell, 1.5);

	if(objcount > 210){
    	  ObjPrim_SetVertexPosition(objspell, 0, -160, -(240-objcount)/6, 0);
    	  ObjPrim_SetVertexPosition(objspell, 1, 64, -(240-objcount)/6, 0);
    	  ObjPrim_SetVertexPosition(objspell, 2, 64, (240-objcount)/6, 0);
    	  ObjPrim_SetVertexPosition(objspell, 3, -160, (240-objcount)/6, 0);
	}
	if(objcount == 240){Obj_Delete(objspell);}

	objcount++; //controls movement and positioning of effect
	yield;
    }
    Obj_Delete(objspell);
}

task CutInSparen(strText){
	CutinText(strText);
	let obj = ObjPrim_Create(OBJ_SPRITE_2D);
	let objcount = 0;
	let alpha = 0;
	ObjRender_SetBlendType(obj, BLEND_ALPHA);
	Obj_SetRenderPriority(obj, 0.72);
	ObjRender_SetAlpha(obj, alpha);
	ObjPrim_SetTexture(obj, imgCutin);
	ObjSprite2D_SetSourceRect(obj, 0, 1, 494, 501);
	ObjSprite2D_SetDestCenter(obj);
	ObjRender_SetPosition(obj, GetStgFrameLeft, GetStgFrameHeight-240, 0);
	ObjRender_SetColor(obj, 255, 255, 255);
	ascent(i in 0..48){
	    alpha+=3;
	    ObjRender_SetAlpha(obj, alpha);
	    ObjRender_SetPosition(obj, GetStgFrameLeft+120, GetStgFrameHeight-240-objcount, 0);
	    ObjRender_SetScaleXYZ(obj, 0.8, 0.8, 0);
	    objcount++;
	    yield;
	}
	descent(i in 0..48){
	    alpha-=3;
	    ObjRender_SetAlpha(obj, alpha);
	    ObjRender_SetPosition(obj, GetStgFrameLeft+120, GetStgFrameHeight-240-objcount, 0);
	    objcount++;
	    yield;
	}
	Obj_Delete(obj);
}

task CutinText(strText){
    let objtext = ObjText_Create();
    ObjText_SetText(objtext, strText);
    Obj_SetRenderPriority(objtext, 0.74);//Render above cutin
    ObjText_SetFontSize(objtext, 14);
    ObjText_SetFontColorTop(objtext, 255, 128, 64);
    ObjText_SetFontColorBottom(objtext, 255, 128, 64);
    ObjText_SetFontBold(objtext, true);
    ObjText_SetFontBorderType(objtext, BORDER_FULL);
    ObjText_SetFontBorderColor(objtext, 200, 200, 200);
    ObjText_SetFontBorderWidth(objtext, 2);
    ObjRender_SetPosition(objtext, 15, GetStgFrameHeight-30, 0);
    loop(300){yield;}
    Obj_Delete(objtext);
}

task ShotHit(EffectX, EffectY, EffectA, type){ //GTBOT. Effect after shots hit an enemy
	if(!AllowShotDecay){return;}
	let obj3 = ObjPrim_Create(OBJ_SPRITE_2D);
	let obj3_time = 0;
	ObjRender_SetBlendType(obj3, BLEND_ALPHA);
	ObjRender_SetAlpha(obj3, 200);
	Obj_SetRenderPriority(obj3, 0.59);
	ObjPrim_SetTexture(obj3, imgEffect);
	ObjSprite2D_SetSourceRect(obj3, 66, 21, 79, 33);
	ObjSprite2D_SetDestCenter(obj3);
	ObjRender_SetAngleZ(obj3, EffectA+90);
	ObjRender_SetX(obj3, EffectX);
	ObjRender_SetY(obj3, EffectY);
	let a = 145;
	while(!Obj_IsDeleted(obj3)){
		obj3_time++;
		if(obj3_time==3){
			ObjSprite2D_SetSourceRect(obj3, 66, 10, 79, 21);
		}
		if(obj3_time==6){
			ObjSprite2D_SetSourceRect(obj3, 6, 0, 79, 11);
		}
		if(obj3_time==9){Obj_Delete(obj3);}
		ObjRender_SetAlpha(obj3, a-obj3_time*8);
		ObjRender_SetScaleXYZ(obj3, 1+obj3_time/8, 1+obj3_time/8, 1);
		ObjRender_SetPosition(obj3, ObjRender_GetX(obj3)+6*cos(EffectA), ObjRender_GetY(obj3)+6*sin(EffectA), 0);
		
		yield;
	}
}

task ScreenShakeA1(shaketime, intensity){ //GTBOT
	let x = Get2DCameraX;
	let y = Get2DCameraY;
	while(shaketime>0){
		Set2DCameraFocusX(GetStgFrameWidth/2 + rand(-intensity, intensity));
		Set2DCameraFocusY(GetStgFrameHeight/2 + rand(-intensity, intensity));
		shaketime--;
		yield;
	}
	Set2DCameraFocusX(GetStgFrameWidth/2);
	Set2DCameraFocusY(GetStgFrameHeight/2);
	yield;
}

task ScreenShakeA2(intensity, maxintensity){ //GTBOT
	let x = Get2DCameraX;
	let y = Get2DCameraY;
	if(intensity>maxintensity){
		while(intensity>maxintensity){
			Set2DCameraFocusX(GetStgFrameWidth/2 + rand(-intensity, intensity));
			Set2DCameraFocusY(GetStgFrameHeight/2 + rand(-intensity, intensity));
			intensity-=0.5;
			yield;
		}
	}else if(intensity<maxintensity){
		while(intensity<maxintensity){
			Set2DCameraFocusX(GetStgFrameWidth/2 + rand(-intensity, intensity));
			Set2DCameraFocusY(GetStgFrameHeight/2 + rand(-intensity, intensity));
			intensity+=0.5;
			yield;
		}
	}
	Set2DCameraFocusX(GetStgFrameWidth/2);
	Set2DCameraFocusY(GetStgFrameHeight/2);
	yield;
}


task Particle(deX, deY, angX, deAlpha, deScale){ //GTBOT. Graze particles!
	if(TotalParticleCount>=MaximumParticles){return;}
	if(AllowGrazePart != true){return;}
	let obj = ObjPrim_Create(OBJ_SPRITE_2D);
	ObjRender_SetBlendType(obj, BLEND_ADD_RGB);
	Obj_SetRenderPriority(obj, 0.49);
	ObjPrim_SetTexture(obj, imgEffect);
	ObjSprite2D_SetSourceRect(obj, 0, 234, 62, 296);
	ObjSprite2D_SetDestRect(obj, -rand(1,4), -rand(1,7.5), rand(1, 4), rand(1, 7.5));
	ObjRender_SetAngleXYZ(obj, 0, 0, angX);
	ObjRender_SetPosition(obj, deX, deY, 0);
	ObjRender_SetAlpha(obj, deAlpha);
	ObjRender_SetColor(obj, 155, 155, 155);

	let scale = deScale;
	let randX = rand(75, 350);
	let randY = rand(75, 350);
	
	TotalParticleCount++;
	while(Obj_IsDeleted(obj)==false){
		scale += (-0.05)/TimeSpeed;
		deX = deX+(randX/100/TimeSpeed)*cos(angX);
		deY = deY+(randX/100/TimeSpeed)*sin(angX);
		ObjRender_SetPosition(obj, deX, deY, 0);	
		ObjRender_SetAngleXYZ(obj, 0, 0, angX+deX+deY+scale*45);
		ObjRender_SetScaleXYZ(obj, scale, scale, scale);
		ObjRender_SetAlpha(obj, deAlpha+scale*20);
		if(scale<0.01){Obj_Delete(obj)}
		yield;
	}
	TotalParticleCount--;
	Obj_Delete(obj);
}

task MapleLeaf(deX, deY, angX, deAlpha, deScale){ //GTBOT
	deScale = deScale*1.25;
		let obj = ObjPrim_Create(OBJ_SPRITE_LIST_2D); 
		ObjRender_SetBlendType(obj, BLEND_ALPHA);
	Obj_SetRenderPriority(obj, 0.49);
	ObjPrim_SetTexture(obj, imgEffect);
	ObjSpriteList2D_SetSourceRect(obj, 0, 48, 32, 80);
	ObjSpriteList2D_SetDestCenter(obj);
	ObjRender_SetAngleXYZ(obj, 0, 0, angX);
	ObjRender_SetPosition(obj, deX, deY, 0);
	ObjRender_SetAlpha(obj, deAlpha);

	let scale = deScale;
	let randX = rand(-105, 105);
	let randY = rand(-105, 105);
	let	ang2 = rand(0, 360);
	
	while(scale>0.01){
		scale += ((-0.2)/2)/TimeSpeed;
		deX += (randX/20)/TimeSpeed;
		deY += (randY/20)/TimeSpeed;
		angX += (randX/15)/TimeSpeed;
		ang2 += (randX/15)/TimeSpeed;
		ObjSpriteList2D_ClearVertexCount(obj);
		ObjSpriteList2D_SetSourceRect(obj, 0, 48, 32, 80);
		ObjSpriteList2D_SetDestCenter(obj);
		ObjSpriteList2D_AddVertex(obj);
		
		ObjRender_SetPosition(obj, deX, deY, 0);
		ObjRender_SetAngleXYZ(obj, ang2, angX, (ang2+angX)/2);
		ObjRender_SetScaleXYZ(obj, scale, scale, scale);
		ObjRender_SetAlpha(obj, deAlpha-scale*20);
		yield;
	}
	Obj_Delete(obj);
}

	task TMagicCircle{ //Invincibility circle, ripped from Random Player Generator
		let countVertex = 64;
		let listRadius = [];
		loop(countVertex)
		{
			listRadius = listRadius ~ [0];
		}

		let path = current ~ "Default_Player_MagicCircle.png";
		let obj = ObjPrim_Create(OBJ_PRIMITIVE_2D);
		ObjPrim_SetPrimitiveType(obj, PRIMITIVE_TRIANGLESTRIP);
		ObjPrim_SetVertexCount(obj, countVertex);
		ObjRender_SetBlendType(obj, BLEND_ADD_RGB);
		Obj_SetRenderPriority(obj, 0.60);
		ObjPrim_SetTexture(obj, path);
		ascent(iVert in 0..countVertex / 2)
		{
			let left = iVert * 128;
			let indexVert = iVert * 2;
			ObjPrim_SetVertexUVT(obj, indexVert + 0, left, 0);
			ObjPrim_SetVertexUVT(obj, indexVert + 1, left, 64);		
		}

		let cx = 0;
		let cy = 0;
		let maxRadius = 128;
		let alpha = 0;
		let frame = 0;
		let angleRender = 0;
		let frameInvOld = 0;

		while(true)
		{
			let frameInv = GetPlayerInvincibilityFrame();

			if(frameInv <= 0)
			{
				Obj_SetVisible(obj, false);
				frameInvOld = 0;
			}
			else
			{
				if(frameInvOld == 0)
				{
					ascent(iVert in 0..countVertex)
					{
						listRadius[iVert] = 0;
					}
					alpha = 0;
					frame = 0;
				}
				frameInvOld = frameInv;

				let px = GetPlayerX();
				let py = GetPlayerY();

				alpha += 1 / 120;
				alpha = min(alpha, 1);
				angleRender += 360 / countVertex / 2;
				Obj_SetVisible(obj, true);

				frameInv = min(100, frameInv);
				let rRate = frameInv / 100;

				ascent(iVert in 0..countVertex / 2)
				{
					let indexVert = iVert * 2;
					let angle = 360 / (countVertex / 2 - 1) * iVert;

					let vx1 = listRadius[indexVert] * cos(angle);
					let vy1 = listRadius[indexVert] * sin(angle);
					ObjPrim_SetVertexPosition(obj, indexVert + 0, vx1, vy1, 0);

					let vx2 = listRadius[indexVert+1] * cos(angle);
					let vy2 = listRadius[indexVert+1] * sin(angle);
					ObjPrim_SetVertexPosition(obj, indexVert + 1, vx2, vy2, 0);

					if(frame >= 0)
					{
						let dr = (maxRadius * rRate - listRadius[indexVert]) / 8;
						listRadius[indexVert] = listRadius[indexVert] + dr;
					}
					if(frame > 10)
					{
						let rRateIn = rRate - 0.12;
						if(rRateIn < 0){rRateIn=0;}
						let dr= (maxRadius * rRateIn - listRadius[indexVert + 1]) / 16;
						listRadius[indexVert + 1] = listRadius[indexVert + 1] + dr;
					}

				}

				ObjRender_SetColor(obj, 192 * alpha, 192 * alpha, 255 * alpha);
				ObjRender_SetPosition(obj, px, py, 0);
				ObjRender_SetAngleZ(obj, angleRender);

				frame++;
			}

			yield;
		}
	}


function DigitToArray(digit, count){ //GTBOT
	let res = [];
	digit = truncate(digit);

	loop{
		let tnum = truncate(digit % 10);
		digit /= 10;
		res = [tnum] ~ res;
		if(truncate(digit) == 0){break;}
	}

	loop(max(0, count - length(res))){
		res = [0] ~ res;
	}

	return res;
}

function GetClosestEnemyID(x1, y1){ //GTBOT
	let earray = GetAllEnemyID;
	if(GetEnemyBossSceneObjectID != ID_INVALID){earray = GetEnemyBossObjectID;}
	let objid = ID_INVALID;
	let dist = 99999;
	let size = max(-1, length(earray));
	if(size>=0){
		ascent(b in 0..size){
			let eID = earray[b];
			let edist = GetDistance(x1,y1,ObjRender_GetX(eID),ObjRender_GetY(eID));
			if(edist<dist){
				dist = edist;
				objid = eID
			}
		}
	}
	return objid;
}

function ArrayMin(array){ //GTBOT
    let min = array[0];
    ascent(i in 1..length(array)){
        if(array[i] < min){ min = array[i]; }
	}
    return min;
}

function ArrayMax(array){ //GTBOT
    let max = array[0];
    ascent(i in 1..length(array)){
        if(array[i] > max){ max = array[i]; }
    }
    return max;
}

function CheckOutsideScreen(objectID, distance){ //GTBOT. Determines whether or not the player is outside of the screen
	let COSvar = false;
	
	if(ObjRender_GetX(objectID)>GetStgFrameWidth+distance||ObjRender_GetX(objectID)<-distance||
	ObjRender_GetY(objectID)>GetStgFrameHeight+distance||ObjRender_GetY(objectID)<-distance){
		COSvar=true;
	}
	
	return COSvar;
}

function GetDistance(x1,y1,x2,y2){ //GTBOT
	return(((x2-x1)^2+(y2-y1)^2)^(1/2));
}

function AnyKey(type){ //GTBOT
	let skck = false;
	if(GetVirtualKeyState(VK_LEFT) == type){skck=true;}
	if(GetVirtualKeyState(VK_RIGHT) == type){skck=true;}
	if(GetVirtualKeyState(VK_UP) == type){skck=true;}
	if(GetVirtualKeyState(VK_DOWN) == type){skck=true;}
	return skck;
}
function AllKeysFree{ //GTBOT
	let skck = false;
	if(GetVirtualKeyState(VK_LEFT) == KEY_FREE &&
	GetVirtualKeyState(VK_RIGHT) == KEY_FREE &&
	GetVirtualKeyState(VK_UP) == KEY_FREE &&
	GetVirtualKeyState(VK_DOWN) == KEY_FREE){skck=true;}
	return skck;
}
function AnyKeyHeld{ //GTBOT
	let skck = false;
	if(GetVirtualKeyState(VK_LEFT) == KEY_HOLD ||
	GetVirtualKeyState(VK_RIGHT) == KEY_HOLD ||
	GetVirtualKeyState(VK_UP) == KEY_HOLD ||
	GetVirtualKeyState(VK_DOWN) == KEY_HOLD){skck=true;}
	return skck;
}
function GetPlayerMoveAngle{ //GTBOT
	let angle = 270;
	if(GetVirtualKeyState(VK_DOWN)==KEY_HOLD){
		if(GetVirtualKeyState(VK_RIGHT)==KEY_HOLD){
			angle = 45;
		}else if(GetVirtualKeyState(VK_LEFT)==KEY_HOLD){
			angle = 135;
		}else{
			angle = 90;
		}
	}
	else if(GetVirtualKeyState(VK_UP)==KEY_HOLD){
		if(GetVirtualKeyState(VK_RIGHT)==KEY_HOLD){
			angle = 315;
		}else if(GetVirtualKeyState(VK_LEFT)==KEY_HOLD){
			angle = 225;
		}else{
			angle = 270;
		}
	}else if(GetVirtualKeyState(VK_RIGHT)==KEY_HOLD){
		angle = 0;
	}else if(GetVirtualKeyState(VK_LEFT)==KEY_HOLD){
		angle = 180;
	}
	return angle;
}


task CreateObjectSound(name){ //GTBOT
	//id is a dummy variable for easier navigation
	let objSound = ObjSound_Create;
	ObjSound_Load(objSound, current~name~".wav");
	ObjSound_SetSoundDivision(objSound, SOUND_SE);
	ObjSound_SetRestartEnable(objSound, true);
	GlobalSounds = GlobalSounds~[objSound];
	GlobalSndStr = GlobalSndStr~[name];
}

task StopAllSounds{ //GTBOT
	ReallyPlaying = [];
	ascent(i in 0..length(GlobalSounds)){
		if(ObjSound_IsPlaying(GlobalSounds[i])){
			ReallyPlaying = ReallyPlaying~[GlobalSounds[i]];
		}
	}
	ReallyPlaying = ReallyPlaying~[ID_INVALID];
	if(length(ReallyPlaying)>0){
		ascent(i in 0..length(ReallyPlaying)){
			ObjSound_Stop(ReallyPlaying[i]);
		}
	}
}
task ResumeSounds{ //GTBOT
	if(length(ReallyPlaying)>0){
		ascent(i in 0..length(ReallyPlaying)){
			ObjSound_Play(ReallyPlaying[i]);
		}
	}
}

task PlaySound(name){ //GTBOT
	let ID = -1;
	ascent(i in 0..length(GlobalSndStr)){
		if(GlobalSndStr[i]==name){ID = i; break;}
	}
	ObjSound_Play(GlobalSounds[ID]);
}



function GetNumSize(value){ //GTBOT
	if(value<=1){return 1;}
	else{return truncate(log10(value))+1;}
}
'''
