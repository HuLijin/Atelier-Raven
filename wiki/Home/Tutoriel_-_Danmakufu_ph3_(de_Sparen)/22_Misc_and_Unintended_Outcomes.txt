Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2015-09-01T17:32:55+02:00

====== 22 Misc and Unintended Outcomes ======

===== Notes on Tasking and Bullet Delay =====

This section is meant to specifically warn people who emulate my style of calling non-looping tasks for the sole purpose of looping attacks. First and foremost...

'''
task TFinalize{
  while(ObjEnemy_GetInfo(objBoss,INFO_LIFE)>0){yield;}
  yield;
  DeleteShotAll(TYPE_ALL,TYPE_ITEM);
  Obj_Delete(objBoss);
  DeleteShotAll(TYPE_ALL,TYPE_IMMEDIATE);
  CloseScript(GetOwnScriptID());
'''

'''
}
'''


[*] **Note the presence of the yield; Depending on your scripting style, if you do not use that yield (or multiple yields)... unwanted things can happen, such as effects not deleting and bullets spawning from (0,0). It is recommended that you yield; more than one frame if you don't want to immediately rush into the next single or if you spawn bullets with more delay than 0 frames.** 
However, if your scripting style us set up so that all tasks end and no bullets can be fired, then you may want to have no yields at all after the while loop has ended.

**Basically, in ph3, tasks continue going until they finish or until the script terminates. If you spawn bullets after DeleteShotAll(TYPE_ALL,TYPE_IMMEDIATE); OR have bullets with delay, then they will not be deleted and will exist in the next script. The same thing goes for graphics. If you don't set SetAutoDeleteObject(true);, the graphics will continue to exist until deleted manually. This means that you must terminate the effect tasks manually. Make sure that the amount of wait time before they are deleted is less than or equal time to the number of yield;s in TFinalize.**


	task TestTask{
   	let angleT = rand(0,360);
   	loop(15){
   	  loop(6){
   	    CreateShotA1(GetEnemyX(objBoss), GetEnemyY(objBoss), 4, angleT, 234, 5);
   	    CreateShotA1(GetEnemyX(objBoss), GetEnemyY(objBoss), 4, angleT+1, 234, 7);
   	    CreateShotA1(GetEnemyX(objBoss), GetEnemyY(objBoss), 4, angleT-1, 234, 7);
   	    angleT+=360/6;
   	  }
   	  PlaySE(bullet);
   	  loop(5){yield;}
   	  angleT+=19;
   	}
   }

Let us assume that this task is called when the boss has almost zero HP. It will continue to loop, waiting 5 frames each time. Since the objBoss is deleted after 1 frame in the sample TFinalize, the rest of the bullets will form at (0,0) and will not be deleted because the shot deletion functions were called BEFORE the bullets were created (since they have delay). That's where this comes in.


		if(ObjEnemy_GetInfo(objBoss, INFO_LIFE) <= 0){return;}//Default kill to prevent (0,0) spawning

If you insert this right before the shots are created (after loop(15) in this case), and have a yield; in TFinalize, the task will be terminated on the spot if the boss does not exist. As a result, the window in which bullets can spawn will be dramatically shortened. If your wait time in TFinalize is greater than the maximum delay you have on a bullet, this code will prevent bullets from spawning into the next attack.

Basically, as CK Crash said, "You want TFinalize to be the absolute last thing to run." That way, all of your tasks have terminated and there is no chance of anything appearing after the script has been closed. An alternate solution is to yield until all bullet and graphic spawning tasks have ended before running TFinalize, although this will require other workarounds for death effects.

If all of this doesn't work, there is, of course, a cheap way out. Please don't run this unless you've deleted all existing shots using DeleteShotAll.


		let arr = GetShotIdInCircleA2(GetCenterX,GetCenterY,1000,TARGET_ENEMY);
	   ascent(i in 0..length(arr)){Obj_Delete(arr[i]);}

This assumes that GetCenterX and GetCenterY have been defined (they can be found under Helpful Functions), and will get the ID of every single existing shot on the screen that has been fired by the enemy. It will then delete them all. Note that if you have 1000 bullets, indexing an array with 1000 values will take a while. That's why this should only be used as a last resort OR when you've already cleared out pretty much every existing enemy shot.

===== SetAutoDeleteObject(false); =====

If you SetAutoDeleteObject(false) for any reason or leave it as is (it is defaulted to false), you will have to delete all of your objects (graphics and effects, among other things) manually. Use DeleteShotAll to delete shots and lasers. You will have to manually delete Sprite and Primitive objects and other miscellaneous objects before the script terminates.

Note that many function libraries with graphics assume that SetAutoDeleteObject is set to true, and that not all of them have manual deletion of their objects (such as GTBot's original cut-in library). If SetAutoDeleteObject is being a pain, Notify User Events stored in the plural using NotifyEventAll in the single and have whatever objects you want to spawn at the end of a single spawn in the plural so that they will not be deleted in the single. SetAutoDeleteObject only auto deletes objects created in the file it is called in.

===== return; vs. break; =====

Now, the difference between return; and break;

break; breaks out of a loop such as a while, loop, ascent, or descent. It will kill the innermost loop. Use return (without a return value - simply a ;) to return a void value for the task, and the task will terminate on the spot. It can be helpful to use return; (but not as the last line of a task. There is a return; at the end of TFinalize because mkm had it there in the sample scripts. It serves no practical purpose and is merely decoration (as far as I know).

===== Parentheses or no parentheses? =====

From Drake:

"Danmakufu is a parsed language and one lazymode shortcut it provides is that you don't have to add the empty () to call a function with no parameters (whereas in compiled languages and whatnot you generally have to). I usually omit the parentheses myself, but when posting I would rather use them than not, since it makes it obvious that I'm talking about a function. That's all."

Source: [Link]

For functions and tasks, feel free to omit the parentheses. Unless it's loop(), in which case it is recommended that you either loop{ or loop(int){ rather than loop(){.

===== Threads and coroutines (Advanced) =====

From Blargel:

"I'd like to point out that the tasks that Danmakufu uses are not truly threads that run independently. If they were threads, they would indeed have some overhead processing that occurs when context switching. However, tasks are actually coroutines which are very different from threads. While threads are for concurrent processing, coroutines are still sequential so there is no context switching to process. It's really just a fancy way to give a sequence of directions to the program while writing it in a non-sequential way.

tl;dr Tasks are not threads and are not slow.

Also, have a [stackoverflow link]."

Source: [Link]

Note: Ultima has requested multithreading for ph3 and it is NOT POSSIBLE without mkm rewriting the engine. So unfortunately, it will not be happening anytime soon.

===== Regarding semicolons =====

From Drake:

"Everything is interpreted by Danmakufu's scripting engine, so it's basically just an interpreter quirk. Shot data scripts need no semicolons because no statements are being executed, it might as well be XML or something. Statements with # are headers and are also just interpreted. The #include statements are just replaced by the referenced script, so again nothing is being executed.

Not too sure about return not requiring semicolons since I always use them anyways. I do know Danmakufu allows you to omit semicolons if a statement is the only one in a bracket, like while(x > y){ z = a } but it's still really weird and I would never suggest omitting them just because you can."

Source: [Link]

===== #include in an #include =====

In Danmakufu, it is possible to #include inside of an included file. However, be aware that the order in which you include files and the nesting of includes determines whether or not an included file will work correctly. For example, if you define GetCenterX() in one include, other includes must include that file or be included after that file has been included in order to not bring up an error.

===== Commenting =====

//This is a comment
/*This is a comment*/
/*This
is 
a
comment
*/
///This may or may not be parsed as a comment. BEWARE.
/** This may or may not be parsed as a comment. BEWARE. **/
/* ****************
This is a comment.
**************** */

===== List of Helpful Functions =====

 function wait(let frames){
	 loop(frames){yield;}
 }
 function WaitForZeroEnemy{
	 while(length(GetAllEnemyID()) > 0){yield;}
 }
 function GetCenterX{
	 return GetStgFrameWidth/2;
 }
 function GetCenterY{
	 return GetStgFrameHeight/2;
 }
 function rand_int(min, max){
	 return round(rand(min, max))
 }
 function sec(n) { return 1/cos(n); }
 function csc(n) { return 1/sin(n); }
 function cot(n) { return 1/tan(n); }
 function GetAtanAngle(obj,obj2){
	 let angle=atan2(ObjMove_GetY(obj2)-ObjMove_GetY(obj),ObjMove_GetX(obj2)-ObjMove_GetX(obj));
	 return angle;
 }
 function GetPointAngle(x1,y1,x2,y2){
	 let angle=atan2(y1-y2,x1-x2);
	 return angle;
 }
 function GetDistance(x1,y1,x2,y2){
	 return(((x2-x1)^2+(y2-y1)^2)^(1/2));
 }
 function DelaySE(sfx, time){//Assumes that sfx is the path of a loaded sound effect.
   loop(time){
	 yield;
   }
   PlaySE(sfx);
 }
NOTE: The following task DOES NOT WORK for Stage Enemies. After the frame variable hits 0, the enemies will take no damage for the rest of the bomb duration, and will most likely escape completely unscathed. Only use this for Boss Single scripts.

 task SetDamageRateAtFrame(obj, shot,bomb,frame){//Talos
   ObjEnemy_SetDamageRate(obj, 0,0);
   let time=frame;
   while(IsPlayerSpellActive){ //Prevents Bomb Damage from previous attack
	 time--;
	 yield;
   }
   while(time>0){
	 time--;
	 yield;
   }
   ObjEnemy_SetDamageRate(obj,shot,bomb);
 }
